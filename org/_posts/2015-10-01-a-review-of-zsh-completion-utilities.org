#+HTML_DOCTYPE: html5
#+BEGIN_HTML
---
layout: page
title: A Review of ZSH Completion
category: note
---
#+END_HTML

#+BEGIN_HTML
<hr>
#+END_HTML

* 
#+ATTR_HTML: :display none
In 2007, ZSH started to experience some real growth. Increasingly rabid
IRC-based advocacy had finally stirred many into dissatisfaction with the
comparatively inflexible tab-completion system of bash; one of the many new
users was me. 


Despite it's maverick status amongst shells at the time (if I may flatter
myself) switching was largely painless and ZSH has grown into it's own as a
powerful shell with a large community, and has risen to be a vogue shell of
bearded necks everywhere.

One thing that many new users of zsh found initially appealing was ZSH's lengthy
and exceptionally comprehensive documentation; famous for it's enumeration of
details and digressions that involve extensive use of man page 'end notes' (some
of which themselves have manpage 'footnotes') occassionally even describing
features or modules of zsh that never existed.

ZSH's creator, Peter Stephenson is largely responsible for this largely great
documentation, but, like most of us who set out to change the world of
programming, he found it difficult to manage his own programs.

As ZSH and it's completion system became more sophisticated, the documentation
itself began to become one of the largest source of question marks on zsh-user.

ZSH completion documentation has the unique distinction of supporting a wide
range of interpretations and has the potential to generate critical theory
literature for years. Eschewing logical development or programming examples,
reading the completion system or widget documentation begins for most readers as
a science but quickly devolves into a mutated site-function guess-and-check.

I will not be addressing any of the following:
- How to set up completion and associated zstyles
- Naming convention (e.g ~_binary~)
- Adding completion

*  Standard UNIX argument completion with ~_arguments~
The general structure of a UNIX style command completion scripts is as follows


1) An entry point that processes the command line string which is executed upon =<TAB>=, sometimes removing the command name to aid processing.
2) A completion function for each subcommand that wraps ~_arguments~
3) One function for each type of object, referred to as a /tag/ in ZSH nomenclature.
4) A function to handle special values, files, sockets, fifos

Understanding /_arguments/ will get you through the majority of completion
scripts that you will need to write in ZSH and should be fully understood. 

=zshcompsys(1)= itself provides a lengthy but occassionally ambiguous treatment
of the function, I'll try to clear up some practical details here.

** The structure of ~_arguments~ 

The function _arguments has been described as having `the syntax from hell', but
with the arguments already laid out in front of you it doesn't look so bad. The
are three types of argument: options to _arguments itself, arguments saying how
to handle options to the command (i.e. `p4 diff'), and arguments saying how to
handle normal arguments to the command.

The following is an excerpt from the /git-merge/ completion function and covers
some important fundamentals of argument parsing.
#+BEGIN_SRC sh
  _arguments -w -S -s \
    $merge_options \
    '-m[set the commit message to be used for the merge commit]:merge message' \
    '(--no-rerere-autoupdate)--rerere-autoupdate[allow the update the index]' \
    '(--rerere-autoupdate)--no-rerere-autoupdate[do not allow update the index]' \
    '--abort[restore the original branch and abort the merge operation]' \
    '*: : __git_commits -O expl:git_commit_opts'
#+END_SRC

=-s= conveys that single-letter options are allowed, i.e. they can be combined
as in `-ft', although this doesn't prevent you from acceping multiple word
options either. ~-w~ is related; in combination with ~-s~ it means that the
options can stack even if one of them itself takes an argument.

For example, ~tar -cf $FILE~ could be processed in this way, as the option after
~-f~ indicates the file we'd be processing (further options AFTER ~-f~ would be
valid as well)


~-S~ is completely unrelated, it indicates that the completion function
shouldn't complete options after =--=, which is a common UNIX 'pattern' to
indicate options have ended.



* Utility Functions

** Creating a dummy first argument
The following is an extract of the iproute2 argument handling in [[https://github.com/zsh-users/zsh/blob/master/Completion/Unix/Command/_ip][=_ip=]]

#+BEGIN_SRC sh
local args
args=(
  # Command word
  /$'[^\0]#\0'/
  'l*ink:configure network device:$link_cmds' \
  'addrlabel:manage addrlabel:$addrlabel_cmds' \
  'a*ddr:manage protocol address:$addr_cmds' \
)
_regex_arguments _command 
#+END_SRC


** ~_pick_variant~ to add options depending upon the version of a program.
#+BEGIN_SRC shell-script
local arguments
# We supply a regex to _pick_variant, in this case checking gor the string `gnu`
if ! _pick_variant gnu=gnu unix --help; then
  arguments=('-g[This flag only works on gnu distributions of this binary]')
else
  arguments=('-a[Otherwise this flag is available]')
fi
#+END_SRC


** Match an ambiguous clause with ~_guard~ 
The ~_guard~ can break between two tags, dependent upon the regex; if this
doesn't seem extraordinarily useful to you, you're not alone -- In the body of
existing ZSH completion scripts, ~_guard~ is typically used an the /action/ for
the specification pased into ~_arguments~ and similar functions.

The =zshcompsys= manpage itself describes behavior reminiscent of the completion
behavior of ~fc(1)~
=_guard=
#+BEGIN_QUOTE
  As an example, consider a command taking the options -n and -none,
  where -n must be followed by a numeric value in the same word. 

zshcompsys(4)
#+END_QUOTE

In the interest of +laziness+ expedience, I will quote ~_fc~ here.
#+BEGIN_SRC sh
if [[ -n $state ]]; then
  zstyle -s ":completion:${curcontext}:" list-separator sep || sep=--
  if [[ -z ${line:#*=*} ]] && compset -P '*='; then
    _message -e replacements 'replacement'
  elif [[ -prefix [0-9] ]]; then
    events=( ${(0)"$(printf "%-${#HISTNO}.${#HISTNO}s $sep %s\0" "${(kv)history[@]}")"} )
    _wanted -2V events expl "$state_descr" compadd -M "B:0=" -ld events - \
        "${events[@]%% *}"
  elif [[ -prefix - ]]; then
    for num cmd in "${(kv@)history}"; do
      (( num=num - HISTNO ))
      events+=( "${(r.1+$#HISTNO.)num} $sep $cmd" )
    done
    _wanted -2V events expl "$state_descr" compadd -ld events - \
        "${events[@]%% *}"
  else
    _wanted events expl "$state_descr" compadd -S '' - \
        ${${history%%[=[:IFS:]]*}:#[0-9-]*} || _guard "[0-9]#" event
  fi
fi && ret=0
#+END_SRC

*** Example
file:/usr/share/zsh/5.1.1/functions/_fc
 
 
* Examples
A statement about these examples should be made here

** Delimited values with final option
A common scenario that occurs in commands such as /libcap/'s capability
manipulation toolchain, /bintools/ and /coreutils/ is the requirement to
complete a list of arbitrary keywords, each with a unix-style (equal sign)
option after each one.

An example of such a command is exemplified by ~setcap~

#+BEGIN_HTML
<section class="terminal-example">
<pre class="terminal-example">
<samp class="terminal-example">
% setcap cap_sys_rawio,cap_sys_pacct=<div class="blinking-cursor">â–ˆ</div>
<span class="yellow"> -- operator -- </span>
e  -- effective
i  -- inheritable
p  -- permitted
</samp>
</pre>
</section>
#+END_HTML

You might initially look at the ~chmod~ completion, and this would get you far,
however the completion script itself is quite long. The core of the unix options
completion lies in the following.

#+BEGIN_SRC sh
list_terminator='*[=]' # Corresponds to `=` 
delimiter=',' # The character that delimits the list
options=("e:effective", "i:inheritable", "p:permitted") # Valid options
case $state in
  # compset -P checks if we've reached a user entering a $list_terminator
  if compset -P $list_terminator; then
    _describe -t options "options" options
  else # Otherwise complete from these list of items.
    _values -s $delimiter items 
      'foo[Description of foo]' \
      'bar[Description of bar]'
  fi
  ;;
esac
#+END_SRC

*** Scripts
[[https://github.com/zv/zsh-completions/blob/9ca66cf7d4af9ecfe5c3d91e7b56f24408b7f312/src/_setcap][- setcap]]

** Operating system specific flags with ~$OSTYPE~
#+BEGIN_SRC shell-script
local arguments
arguments=('-b[Base argument]')
# We might add additional arguments based on the operating system
if [[ "$OSTYPE" = (freebsd*|darwin*) ]]; then
  arguments+=('-m[OSX or FreeBSD Specific Flag]')
fi
if [[ $OSTYPE = solaris* ]]; then
  arguments+=('-s[Solaris specific flag]')
fi
if [[ $OSTYPE = linux* ]]; then
  arguments+=('-l[Linux specific flag]')
fi
#+END_SRC

** Sharing implementation details between different completions with =$SERVICE=
adfadf


* Style and Convention
ZSH completion scripts are (fortunately) never given the opportunity to evolve
into the complex balls of mud that a 'real' programming environment affords;
consequently there is much less attention given to the stylistic debates that
are tied to other languages.

This said, there are a few, largely unwritten, rules and conventions that
are 

** Terminology
+ =spec= : Argument Specification
+ =tag= : The 'varieties' of types of objects that are valid completions, e.x a command that takes a set of permissions OR a file as it's next argument. 
** Variables
+ =$state= - The canonical variable for processing which tag you are in.
+ =$expl=  - An idiom for options normally given to compadd at some point, typically an array
+ =$descr= - Argument description variables

* External Resources 
[[http://zsh.sourceforge.net/Guide/zshguide06.html#l144][- The ZSH User Guide - Completion]]
- [[https://twitter.com/dailyzshtip][Daily ZSH Tips]]
