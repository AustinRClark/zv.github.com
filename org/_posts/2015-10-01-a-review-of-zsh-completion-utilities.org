#+HTML_DOCTYPE: html5
#+BEGIN_HTML
---
layout: page
title: A Review of ZSH Completion
excerpt: Walking through ZSH completion, step by step.
tags: 
  - zsh
  - completion
category: note
---
#+END_HTML

* 
#+ATTR_HTML: :display none
ZSH completion scripts rarely capture programmers interest for their elegance; I
myself have called the system /"excruciatingly awful"/ therefore despite my
brilliant jabs and clever anecdotes, I doubt they could capture your interest in
this somewhat spiritless topic for long.

In consideration of this, I have organized these sections in order of greatest
importance to the topic (excepting this first section), so the devoted reader
can stop reading this article at whatever point you lose interest.

In 2007, ZSH started to experience some real growth. Increasingly rabid advocacy
had finally stirred many into dissatisfaction with the inflexible completion
system of other shells (c.f bash); one of these new users was me.

Initially appealing was ZSH's lengthy, albeit comprehensive documentation;
infamous for it's enumeration of digressions, anecdotes and man page '/end
notes/' (occassionally having footnotes themselves), in a medium distinctly
lacking both. This incidentally provides a unique distinction for a manual page
of supporting a wide range of interpretations and the potential to generate
critical theory literature for years, which I am sure is on it's way to becoming
a robust scholarly enterprise.

ZSH's creator, Peter Stephenson is largely responsible for this possibly great
documentation. Like most of us who set out to change the world of programming,
he found it difficult to manage his own programs - ZSH and it's completion
system became more sophisticated, the system and it's related documentation
began to become one of the largest emitters of user question marks on the
mailing list.

In ernest however, it is the single best compendium of information about ZSH
completion. Although /structural/ questions are rarely answered, as a reference,
 it is unmatched.

I will not be addressing any of the following:
- How to set up completion and associated zstyles
- Adding completion

*  The structure of standard argument completion with ~_arguments~
ZSH's completion system is /contextual/, that is, sensitive to the point as
which the user invokes completion. The structure of completion scripts
themselves are broken down to handle this context in a recursive fashion,
starting out very generic e.g "/The user is requesting completion of git/",
becoming more specific as more is learned - "/the current word is in a position
that is usually a command name/" or "/the current word might be a variable
name/" and so on.

Because option parsing follows a general format (regardless of specifics),
virtually all completion scripts contain with the following basic structure, and
attempting to make a completion script that doesn't will be more pain than it is
worth.

1) An entry point (e.g /git/) will processes the command line string. 
2) A function for each subcommand such as /diff/, typically wrapping /_arguments/
3) One function for each type of object, referred to as a /tag/ in ZSH nomenclature.
4) In some cases, functions to handle special values, files, sockets, fifos. 

Not to belabour the points above, but removing the head of the command to is the
easiest way to build /context/ - everything that the shell knows about the
meaning of the command line and the significance of the cursor position, allowing
/_git-diff/ to be completely unaware of /_git/.

Git is a good command to analyse, not just because it is comprehensive, but also
because it reflects many common option handling patterns; Git is run by a single
command, /git/, followed by either flags or an argument giving the particular
git command, again followed by options to /that/ command. A high level view of
what-must-be-completed-when in git demonstrates it's recursive nature
immediately.

#+BEGIN_SRC dot :output-dir ../../images :file zsh-command-structure.svg :cmdline -Kdot -Tsvg
digraph G {
  bgcolor="#002b36";
  node [color=white, fontcolor=white, shape=box];
  edge [color=white];
  git -> "..." -> options;
  git -> " - (minus)" -> "option list";
  git -> diff;
  diff -> "commit [tag]";
  diff -> "remote [tag]";
  diff -> "- (minus)" -> "diff option list";
}
#+END_SRC
#+RESULTS:
[[file:../../images/zsh-command-structure.svg]]


** The structure of ~_arguments~ 
The function /_arguments/ has been described as having `the syntax from hell', but
with the arguments already laid out in front of you it doesn't look so bad. The
are three types of argument: options to _arguments itself, arguments saying how
to handle options to the command (i.e. `p4 diff'), and arguments saying how to
handle normal arguments to the command.


The following is an excerpt from the /p4 diff/ completion function (in turn
excerpted from the manual) and covers some important fundamentals of argument parsing.
#+BEGIN_SRC sh
(( $+functions[_git-diff] )) ||
_git-diff() {
      _arguments -s : \ 
          '-f[diff every file]' \ 
          '-t[include non-text files]' \ 
          '(-sd -se -sr)-sa[opened files, different or missing]' \ 
          '(-sa -se -sr)-sd[unopened files, missing]' \ 
          '(-sa -sd -sr)-se[unopened files, different]' \ 
          '(-sa -sd -se)-sr[opened files, same as depot]' \ 
          '-d-[select diff option]:diff option:' \ 
  '((b\:ignore\ blanks c\:context n\:RCS s\:summary' \ 
    'u\:unified w\:ignore\ all\ whitespace))' \ 
          "*::file:_perforce_files"
  }
#+END_SRC

*** Flags
The excerpt above only has one flag, and it's the most meaningful flag as well,
but I won't waste an opportunity to briefly cover some other very handy flags:

=-s= conveys that single-letter options are allowed, i.e. they can be combined
as in `-ft', although this doesn't prevent you from acceping multiple word
options either. ~-w~ is related; in combination with ~-s~ it means that the
options can stack even if one of them itself takes an argument.

For example, ~tar -cf $FILE~ could be processed in this way, as the option after
~-f~ indicates the file we'd be processing (further options AFTER ~-f~ would be
valid as well)

~-S~ is completely unrelated, it indicates that the completion function
shouldn't complete options after =--=, which is a common UNIX 'pattern' to
indicate options have ended.

*** The optspec
The long strings of option specification that follows the flags to /_arguments/
and a colon are known known as /optspec/s or option specification.

**** Option Naming or /optnames/
/_arguments/ broadly supports 7 different option specification varieties, all of
which can be directly followed by a bracketed explanation string.

***** ~-optname~ , ~+optname~ & ~+-optname~
The simplest form, indicating that +,- or +/-optname are valid options. the
first would match ~foo -optname~, the next ~foo \+optname~. The last matches
both.
***** ~-optname-~, ~-optname+~ or ~-optname=~, ~-optname=-~
Identical to the above, but accepting arguments.
The former accepting command strings without spacing, e.g ~foo -optnamearg~
the latter with spacing: ~foo -optname arg~. An equals sign is identical in
functionality but being delimited by an equals sign, e.g: ~foo -optname=arg~

All colons are escaped.

*** Option Arguments (optarg)


* Utility Functions

** Creating a dummy first argument
The following is an extract of the iproute2 argument handling in [[https://github.com/zsh-users/zsh/blob/master/Completion/Unix/Command/_ip][=_ip=]]

#+BEGIN_SRC sh
local args
args=(
  # Command word
  /$'[^\0]#\0'/
  'l*ink:configure network device:$link_cmds' \
  'addrlabel:manage addrlabel:$addrlabel_cmds' \
  'a*ddr:manage protocol address:$addr_cmds' \
)
_regex_arguments _command 
#+END_SRC


** ~_pick_variant~ to add options depending upon the version of a program.
#+BEGIN_SRC shell-script
local arguments
# We supply a regex to _pick_variant, in this case checking gor the string `gnu`
if ! _pick_variant gnu=gnu unix --help; then
  arguments=('-g[This flag only works on gnu distributions of this binary]')
else
  arguments=('-a[Otherwise this flag is available]')
fi
#+END_SRC


** Match an ambiguous clause with ~_guard~ 
The ~_guard~ can break between two tags, dependent upon the regex; if this
doesn't seem extraordinarily useful to you, you're not alone -- In the body of
existing ZSH completion scripts, ~_guard~ is typically used an the /action/ for
the specification pased into ~_arguments~ and similar functions.

The =zshcompsys= manpage itself describes behavior reminiscent of the completion
behavior of ~fc(1)~
=_guard=
#+BEGIN_QUOTE
  As an example, consider a command taking the options -n and -none,
  where -n must be followed by a numeric value in the same word. 

zshcompsys(4)
#+END_QUOTE

In the interest of +laziness+ expedience, I will quote ~_fc~ here.
#+BEGIN_SRC sh
if [[ -n $state ]]; then
  zstyle -s ":completion:${curcontext}:" list-separator sep || sep=--
  if [[ -z ${line:#*=*} ]] && compset -P '*='; then
    _message -e replacements 'replacement'
  elif [[ -prefix [0-9] ]]; then
    events=( ${(0)"$(printf "%-${#HISTNO}.${#HISTNO}s $sep %s\0" "${(kv)history[@]}")"} )
    _wanted -2V events expl "$state_descr" compadd -M "B:0=" -ld events - \
        "${events[@]%% *}"
  elif [[ -prefix - ]]; then
    for num cmd in "${(kv@)history}"; do
      (( num=num - HISTNO ))
      events+=( "${(r.1+$#HISTNO.)num} $sep $cmd" )
    done
    _wanted -2V events expl "$state_descr" compadd -ld events - \
        "${events[@]%% *}"
  else
    _wanted events expl "$state_descr" compadd -S '' - \
        ${${history%%[=[:IFS:]]*}:#[0-9-]*} || _guard "[0-9]#" event
  fi
fi && ret=0
#+END_SRC

*** Example
file:/usr/share/zsh/5.1.1/functions/_fc
 
 
* Examples
A statement about these examples should be made here

** Delimited values with final option
A common scenario that occurs in commands such as /libcap/'s capability
manipulation toolchain, /bintools/ and /coreutils/ is the requirement to
complete a list of arbitrary keywords, each with a unix-style (equal sign)
option after each one.

An example of such a command is exemplified by ~setcap~

#+BEGIN_HTML
<section class="terminal-example">
<pre class="terminal-example">
<samp class="terminal-example">
% setcap cap_sys_rawio,cap_sys_pacct=<div class="blinking-cursor">█</div>
<span class="yellow"> -- operator -- </span>
e  -- effective
i  -- inheritable
p  -- permitted
</samp>
</pre>
</section>
#+END_HTML

You might initially look at the ~chmod~ completion, and this would get you far,
however the completion script itself is quite long. The core of the unix options
completion lies in the following.

#+BEGIN_SRC sh
list_terminator='*[=]' # Corresponds to `=` 
delimiter=',' # The character that delimits the list
options=("e:effective", "i:inheritable", "p:permitted") # Valid options
case $state in
  # compset -P checks if we've reached a user entering a $list_terminator
  if compset -P $list_terminator; then
    _describe -t options "options" options
  else # Otherwise complete from these list of items.
    _values -s $delimiter items 
      'foo[Description of foo]' \
      'bar[Description of bar]'
  fi
  ;;
esac
#+END_SRC

*** Scripts
[[https://github.com/zv/zsh-completions/blob/9ca66cf7d4af9ecfe5c3d91e7b56f24408b7f312/src/_setcap][- setcap]]

** Operating system specific flags with ~$OSTYPE~
#+BEGIN_SRC shell-script
local arguments
arguments=('-b[Base argument]')
# We might add additional arguments based on the operating system
if [[ "$OSTYPE" = (freebsd*|darwin*) ]]; then
  arguments+=('-m[OSX or FreeBSD Specific Flag]')
fi
if [[ $OSTYPE = solaris* ]]; then
  arguments+=('-s[Solaris specific flag]')
fi
if [[ $OSTYPE = linux* ]]; then
  arguments+=('-l[Linux specific flag]')
fi
#+END_SRC

** Sharing implementation details between different completions with =$SERVICE=
adfadf


* Style and Convention
ZSH completion scripts are (fortunately) never given the opportunity to evolve
into the complex balls of mud that a 'real' programming environment affords;
consequently there is much less attention given to the stylistic debates that
are tied to other languages.

This said, there are a few, largely unwritten, rules and conventions that
are 

** Terminology
+ =spec= : Argument Specification
+ =tag= : The 'varieties' of types of objects that are valid completions, e.x a command that takes a set of permissions OR a file as it's next argument. 
** Variables
+ =$state= - The canonical variable for processing which tag you are in.
+ =$expl=  - An idiom for options normally given to compadd at some point, typically an array
+ =$descr= - Argument description variables

* External Resources 

- [[http://zsh.sourceforge.net/Guide/zshguide06.html#l144][The ZSH User Guide: Completion]]
- [[https://twitter.com/dailyzshtip][Daily ZSH Tips]]
