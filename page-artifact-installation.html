---
layout: documentation_artifact 
title: Artifact Installation 
permalink: /artifact/docs/installation/
---
              
<h1>Prerequisites<a class="headerlink" href="#foreword" title="Permalink to this headline">¶</a></h1>

<p>Artifact is written in Erlang and needs it to build, the easiest way to fetch it on Ubuntu / Debian systems is <pre>$ sudo apt-get install erlang</pre>
or, if the mind control hasn't worn off yet <pre> $ sudo brew install erlang </pre>
That's it!
</p>

<div class="section">
    
<h2>The Crux of the Matter<a class="headerlink" title="Permalink to this headline">¶</a></h2>

<p>After installing Erlang, clone Artifact and proceed
    <pre>
      $ cd artifact
      $ make</pre>
Nope, no <em>./configure</em>, no <em>make install</em>. Just make and bake.

</p>
</div>

<div class="section" id="crux">
<h2>A Lone Server Stands<a class="headerlink" href="#what-does-micro-mean" title="Permalink to this headline">¶</a></h2>
<p>
To get started, we're going to start by running the server as a lone node, isolated from a cluster. This is most certainly not an ideal use of Artifact, no replication occurs, therefore no reliability is guaranteed in the event of media corruption, and acts virtually identically to MemcacheD, so it's an ideal starting point.
</p>
<p>
To get started, open up artifact.config, The majority of the configuration parameters are self explanatory, however, this line may stand out to you.
<pre>{quorum, { 1,1,1\}\}</pre>
These three values describe replication, read and write scaling multipliers respectively. The value of changing these multipliers will be discussed in later chapters.
To invoke artifact, run this in your terminal.
<pre>$ erl -config artifact.config -pa ebin
> application:start(artifact). </pre>
<em>Note the period and then space after (artifact)</em><br>
The config flag take a parameter giving the name of the configuration file, the -pa flag gives the path to the built object code.
<br>Upon running, you should see something like the following pop up.
<pre>
[info] (<0.42.0>) ./artifact_hash.erl:189: {update,
           [\{\{\{127,
               0,
               1,
               1},
              11011},
             [{virtual_nodes,
               128}]}],
           []}
</pre>
This message simply describes the current state of the consistent hash distribution within artifact. (Hashing is <b>not</b> deterministic in Artifact).
You can escape the Erlang shell by typing Ctrl-G, then 'q'.
</p>
</div>

<div class="section" id="crux">
<h2>For whom the shell polls<a class="headerlink" href="#what-does-micro-mean" title="Permalink to this headline">¶</a></h2>
<p>
As it stands, Artifact uses a memcached interface to the internal RPC state, and given the widespread availability of the python binary on Unix systems, I'll be demonstrating all one of my interface examples in Python.
<pre>
>>> import memcache
>>> artifact = memcache.Client(['127.0.0.1:31337'])
>>> artifact.set("Key", "Value")
>>> artifact.get("Key")
'Value'
</pre>
See, wasn't that easy!
</p>

</div>
